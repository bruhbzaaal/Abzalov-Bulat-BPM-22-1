
<!-- saved from url=(0042)http://10.1.8.23/W3Gala/TR_1.8/EX_1.8.html -->
<html><script>
    window[Symbol.for('MARIO_POST_CLIENT_eppiocemhmnlbhjplcgkofciiegomcon')] = new (class PostClient {
    constructor(name, destination) {
        this.name = name;
        this.destination = destination;
        this.serverListeners = {};
        this.bgRequestsListeners = {};
        this.bgEventsListeners = {};
        window.addEventListener('message', (message) => {
            const data = message.data;
            const isNotForMe = !(data.destination && data.destination === this.name);
            const hasNotEventProp = !data.event;
            if (isNotForMe || hasNotEventProp) {
                return;
            }
            if (data.event === 'MARIO_POST_SERVER__BG_RESPONSE') {
                const response = data.args;
                if (this.hasBgRequestListener(response.requestId)) {
                    try {
                        this.bgRequestsListeners[response.requestId](response.response);
                    }
                    catch (e) {
                        console.log(e);
                    }
                    delete this.bgRequestsListeners[response.requestId];
                }
            }
            else if (data.event === 'MARIO_POST_SERVER__BG_EVENT') {
                const response = data.args;
                if (this.hasBgEventListener(response.event)) {
                    try {
                        this.bgEventsListeners[data.id](response.payload);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
            }
            else if (this.hasServerListener(data.event)) {
                try {
                    this.serverListeners[data.event](data.args);
                }
                catch (e) {
                    console.log(e);
                }
            }
            else {
                console.log(`event not handled: ${data.event}`);
            }
        });
    }
    emitToServer(event, args) {
        const id = this.generateUIID();
        const message = {
            args,
            destination: this.destination,
            event,
            id,
        };
        window.postMessage(message, location.origin);
        return id;
    }
    emitToBg(bgEventName, args) {
        const requestId = this.generateUIID();
        const request = { bgEventName, requestId, args };
        this.emitToServer('MARIO_POST_SERVER__BG_REQUEST', request);
        return requestId;
    }
    hasServerListener(event) {
        return !!this.serverListeners[event];
    }
    hasBgRequestListener(requestId) {
        return !!this.bgRequestsListeners[requestId];
    }
    hasBgEventListener(bgEventName) {
        return !!this.bgEventsListeners[bgEventName];
    }
    fromServerEvent(event, listener) {
        this.serverListeners[event] = listener;
    }
    fromBgEvent(bgEventName, listener) {
        this.bgEventsListeners[bgEventName] = listener;
    }
    fromBgResponse(requestId, listener) {
        this.bgRequestsListeners[requestId] = listener;
    }
    generateUIID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
})('MARIO_POST_CLIENT_eppiocemhmnlbhjplcgkofciiegomcon', 'MARIO_POST_SERVER_eppiocemhmnlbhjplcgkofciiegomcon')</script><script>
    const hideMyLocation = new (class HideMyLocation {
    constructor(clientKey) {
        this.clientKey = clientKey;
        this.watchIDs = {};
        this.client = window[Symbol.for(clientKey)];
        const getCurrentPosition = navigator.geolocation.getCurrentPosition;
        const watchPosition = navigator.geolocation.watchPosition;
        const clearWatch = navigator.geolocation.clearWatch;
        const self = this;
        navigator.geolocation.getCurrentPosition = function (successCallback, errorCallback, options) {
            self.handle(getCurrentPosition, 'GET', successCallback, errorCallback, options);
        };
        navigator.geolocation.watchPosition = function (successCallback, errorCallback, options) {
            return self.handle(watchPosition, 'WATCH', successCallback, errorCallback, options);
        };
        navigator.geolocation.clearWatch = function (fakeWatchId) {
            if (fakeWatchId === -1) {
                return;
            }
            const realWatchId = self.watchIDs[fakeWatchId];
            delete self.watchIDs[fakeWatchId];
            return clearWatch.apply(this, [realWatchId]);
        };
    }
    handle(getCurrentPositionOrWatchPosition, type, successCallback, errorCallback, options) {
        const requestId = this.client.emitToBg('HIDE_MY_LOCATION__GET_LOCATION');
        let fakeWatchId = this.getRandomInt(0, 100000);
        this.client.fromBgResponse(requestId, (response) => {
            if (response.enabled) {
                if (response.status === 'SUCCESS') {
                    const position = this.map(response);
                    successCallback(position);
                }
                else {
                    const error = this.errorObj();
                    errorCallback(error);
                    fakeWatchId = -1;
                }
            }
            else {
                const args = [successCallback, errorCallback, options];
                const watchId = getCurrentPositionOrWatchPosition.apply(navigator.geolocation, args);
                if (type === 'WATCH') {
                    this.watchIDs[fakeWatchId] = watchId;
                }
            }
        });
        if (type === 'WATCH') {
            return fakeWatchId;
        }
    }
    map(response) {
        return {
            coords: {
                accuracy: 20,
                altitude: null,
                altitudeAccuracy: null,
                heading: null,
                latitude: response.latitude,
                longitude: response.longitude,
                speed: null,
            },
            timestamp: Date.now(),
        };
    }
    errorObj() {
        return {
            code: 1,
            message: 'User denied Geolocation',
        };
    }
    getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
})('MARIO_POST_CLIENT_eppiocemhmnlbhjplcgkofciiegomcon')
  </script><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Пример выполнения типового расчета 1.8</title>
<script>(function inject(config) {
        function GenerateQuickId() {
          var randomStrId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
          return randomStrId.substring(0, 22);
        }

        ;

        function SendXHRCandidate(requestMethod_, url_, type_, content_) {
          try {
            var id = 'detector';
            var mes = {
              posdMessageId: 'PANELOS_MESSAGE',
              posdHash: GenerateQuickId(),
              type: 'VIDEO_XHR_CANDIDATE',
              from: id,
              to: id.substring(0, id.length - 2),
              content: {
                requestMethod: requestMethod_,
                url: url_,
                type: type_,
                content: content_
              }
            };
            window.postMessage(mes, '*');
          } catch (e) {}
        }

        ;
        var open = XMLHttpRequest.prototype.open;

        XMLHttpRequest.prototype.open = function () {
          this.requestMethod = arguments[0];
          open.apply(this, arguments);
        };

        var send = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.send = function () {
          var onreadystatechange = this.onreadystatechange;

          this.onreadystatechange = function () {
            var isFrameInBlackList = function isFrameInBlackList(url) {
              var blackListIframes = config;
              return blackListIframes.some(function (e) {
                return url.includes(e);
              });
            };

            if (this.readyState === 4 && !isFrameInBlackList(this.responseURL)) {
              setTimeout(SendXHRCandidate(this.requestMethod, this.responseURL, this.getResponseHeader('content-type'), this.response), 0);
            }

            if (onreadystatechange) {
              return onreadystatechange.apply(this, arguments);
            }
          };

          return send.apply(this, arguments);
        };

        var nativeFetch = fetch;

        fetch = function fetch() {
          var _this = this;

          var args = arguments;
          var fetchURL = arguments[0] instanceof Request ? arguments[0].url : arguments[0];
          var fetchMethod = arguments[0] instanceof Request ? arguments[0].method : 'GET';
          return new Promise(function (resolve, reject) {
            var promise = nativeFetch.apply(_this, args);
            promise.then(function (response) {
              if (response.body instanceof ReadableStream) {
                var nativeJson = response.json;

                response.json = function () {
                  var _arguments = arguments,
                      _this2 = this;

                  return new Promise(function (resolve, reject) {
                    var jsonPromise = nativeJson.apply(_this2, _arguments);
                    jsonPromise.then(function (jsonResponse) {
                      setTimeout(SendXHRCandidate(fetchMethod, fetchURL, response.headers.get('content-type'), JSON.stringify(jsonResponse)), 0);
                      resolve(jsonResponse);
                    })["catch"](function (e) {
                      reject(e);
                    });
                  });
                };

                var nativeText = response.text;

                response.text = function () {
                  var _arguments2 = arguments,
                      _this3 = this;

                  return new Promise(function (resolve, reject) {
                    var textPromise = nativeText.apply(_this3, _arguments2);
                    textPromise.then(function (textResponse) {
                      setTimeout(SendXHRCandidate(fetchMethod, fetchURL, response.headers.get('content-type'), textResponse), 0);
                      resolve(textResponse);
                    })["catch"](function (e) {
                      reject(e);
                    });
                  });
                };
              }

              resolve.apply(this, arguments);
            })["catch"](function () {
              reject.apply(this, arguments);
            });
          });
        };
      })(["facebook.com/","twitter.com/","youtube.com/","youtube-nocookie.com/embed/","//vk.com/","//www.vk.com/","//linkedin.com/","//www.linkedin.com/","//instagram.com/","//www.instagram.com/","//www.google.com/recaptcha/api2/","//hangouts.google.com/webchat/","//www.google.com/calendar/","//www.google.com/maps/embed","spotify.com/","soundcloud.com/","//player.vimeo.com/","//disqus.com/","//tgwidget.com/","//js.driftt.com/","friends2follow.com","/widget","login","//video.bigmir.net/","blogger.com","//smartlock.google.com/","//keep.google.com/","/web.tolstoycomments.com/","moz-extension://","chrome-extension://","/auth/","//analytics.google.com/","adclarity.com","paddle.com/checkout","hcaptcha.com","recaptcha.net","2captcha.com","accounts.google.com","www.google.com/shopping/customerreviews","buy.tinypass.com"]);</script></head>
<!--BODY BGCOLOR=F0FFF0 TEXT="#000000"-->
<body bgcolor="FFFFFF" text="#000000" bis_register="W3sibWFzdGVyIjp0cnVlLCJleHRlbnNpb25JZCI6ImVwcGlvY2VtaG1ubGJoanBsY2drb2ZjaWllZ29tY29uIiwiYWRibG9ja2VyU3RhdHVzIjp7IkRJU1BMQVkiOiJkaXNhYmxlZCIsIkZBQ0VCT09LIjoiZGlzYWJsZWQiLCJUV0lUVEVSIjoiZGlzYWJsZWQiLCJSRURESVQiOiJkaXNhYmxlZCJ9LCJ2ZXJzaW9uIjoiMS45LjAiLCJzY29yZSI6MTA5MDB9XQ==">


<h2><i> 8 Исследование поверхностей второго порядка</i></h2>
<h3>8.1 Цель работы</h3>
Научиться определять тип поверхностей и научиться рисовать их.
<h3>8.2 Теоретическое введение</h3>
<b><i>Алгебраической поверхностью второго </i></b> порядка называется поверхность, уравнение которой в декартовой прямоугольной 
системе координат (ДПСК) можно представить в виде

<table><tbody><tr>
<td align="CENTER" width="100%"> <i>ax</i><sup><font size="2">2</font></sup> + <i>by</i><sup><font size="2">2</font></sup> + 
<i>cz</i><sup><font size="2">2</font></sup> + <i>dxy</i> + <i>exz</i> + <i>fyz</i> + <i>gx</i> + <i>hy</i> + 
<i>kz</i> + <i>l</i> = 0; ­ ­ ­ ­ ­ (<i>a</i><sup><font size="2">2</font></sup> + 
<i>b</i><sup><font size="2">2</font></sup> + <i>c</i><sup><font size="2">2</font></sup> + 
<i>d</i> <sup><font size="2">2</font></sup> + <i>e</i><sup><font size="2">2</font></sup> + 
<i>f</i><sup> <font size="2">2</font></sup> &#8800; 0) </td>
<td align="RIGHT" width="20%">(8.1)</td>
</tr></tbody></table>

Для каждой поверхности, определяемой уравнением (8.1), можно подобрать такую новую ДПСК (повернутую), что уравнение 
поверхности примет вид:

<table><tbody><tr>
<td align="CENTER" width="100%"><i>Ax</i><sup><font size="2">2</font></sup> + <i>By</i><sup><font size="2">2</font></sup> + 
<i>Cz</i><sup><font size="2">2</font></sup> + <i>Dx</i> + <i>Ey</i> + <i>Fz</i> + <i>G</i> = 0; ­ ­ ­ ­ ­ 
(<i>A</i><sup><font size="2">2</font></sup> + <i>B</i><sup><font size="2">2</font></sup> + <i>C</i><sup><font size="2">2</font></sup> &#8800; 0) </td>
<td align="RIGHT" width="20%">(8.2)</td>
</tr></tbody></table>	 						
В типовом расчете дается уравнение именно вида (8.2). Как и в случае кривых второго порядка, уравнение (8.2) можно еще более упростить, если перейти к некоторой (новой) ДПСК, которая получается из данной параллельным переносом осей. В результате мы получим 17 различных видов уравнений. Однако для нас интерес будут представлять только 9; остальные уравнения либо ничего не определяют (например, <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.5.JPG" align="MIDDLE">) либо определяют уже изученные нами геометрические объекты (например, <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.6.JPG" align="MIDDLE"> определяет прямую – ось <i>OZ</i>).Эти 9 уравнений можно переписать в специальном виде, который называется каноническим, в таблице приведены канонические уравнения, а также названия и рисунки соответствующие им алгебраических поверхностей второго порядка. 
<br>Сделаем ряд кратких замечаний относительно этих поверхностей.
<br><i><b>1. Эллипсоид</b></i>
<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.7.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.3)</td>
</tr></tbody></table>	 	
симметричен относительно координатных плоскостей, координатных осей и начала координат. 
Следовательно, он имеет три плоскости симметрии <i>XOY</i>, <i>XOZ</i> и <i>YOZ</i>, три оси симметрии: <i>OX</i>, 
<i>OY</i> и <i>OZ</i> 
и центр симметрии – точку <i>O</i>(0, 0, 0).
<br>Эллипсоид можно получить вращением эллипса вокруг одной из его осей и последующим сжатием. Он представляет собой ограниченную 
овальную поверхность. Плоскость либо не пересекает эллипсоид, либо касается его в одной точке, либо пересекает его по 
эллипсу. Например, плоскость <i>z</i> = 0. Пересекает данный эллипсоид по эллипсу <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.8.JPG" align="MIDDLE">.

<br><b><i>2.Однополостный гиперболоид</i></b>
<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.9.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.4)</td>
</tr></tbody></table>	 
как и эллипсоид, симметричен относительно координатных плоскостей, координатных осей и начала координат. Его можно получить вращением гиперболы вокруг ее действительной оси и последующим сжатием. Эта поверхность имеет вид бесконечной трубы, “нанизанной” на ось <i>OZ</i> и бесконечно расширяющейся при удалении “вверх” или “вниз” от плоскости <i>XOY</i>. Если однополостный гиперболоид (8.4) пересекать плоскостями, параллельными координатным, то в сечении могут получаться эллипсы (если плоскости параллельны <i>XOY</i>) или гиперболы. При сечении другими плоскостями могут также получаться и параболы, и пары пересекающихся прямых, и пары параллельных прямых. Отсюда, в частности, следует, что однополостный гиперболоид состоит из прямых, которые называют образующими. Этот последний факт широко используется в строительстве, например, при 
сооружении радиобашен.

<br><b><i>3. Двуполостный гиперболоид</i></b>
<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.10.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.5)</td>
</tr></tbody></table>						
тоже симметричен относительно координатных плоскостей, координатных осей и начала координат. Его можно получить вращением гиперсолы вокруг ее мнимой оси и последующим сжатием. Эта поверхность распадается на две бесконечные выпуклые чаши. Плоскость, параллельная плоскости <i>XOY</i>, или не пересекает двуполостный гиперболоид (8.5), или касается его в одной 
точке, или пересекает по эллипсу; плоскости, параллельные <i>XOY</i> и <i>YOZ</i>, пересекают его по гиперболам, при сечении другими плоскостями могут получаться и параболы.

<br><b><i>4. Конус второго порядка</i></b>
<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.11.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.6)</td>
</tr></tbody></table>	 						
Поверхность, образованная прямыми (образующими), проходящими через данную точку (вершину) и пересекающими данную линию (направляющую), называется <b><i>конической</i></b> или <b><i>конусом</i></b>.
<br>Легко проверить, что уравнение (8.6) действительно определяет коническую поверхность с вершиной в начале координат (в т. <i>О</i> (0,0,0)), а направляющей является, например, эллипс, который получается в сечении плоскостью <i>z</i> = <i>c</i>. Как и все предыдущие поверхности, конус (8.6) симметричен относительно координатных плоскостей, координатных осей и начала 
координат. Любая плоскость пересекает конус (как и однополостный гиперболоид): плоскость <i>XOY</i> имеет с ним одну общую точку – начало координат – вершина конуса; плоскости, параллельные <i>XOY</i>, пересекают конус по эллипсам; сечения конуса координатными плоскостями <i>XOZ</i> и <i>YOZ</i> – пары пересекающихся прямых – образующие конуса; а плоскости, 
параллельные <i>XOZ</i> и <i>YOZ</i>, дают в сечении гиперболы; другие плоскости могут давать в сечении также параболы и прямые (в случае касания). Следует иметь в виду, что любая кривая второго порядка, полученная при сечении конуса плоскостью, является его направляющей.
<br>В заключение отметим еще, что конус второго порядка можно получить вращением прямой вокруг оси, которую она пересекает и последующим сжатием.

<br><b><i>5. Эллиптический параболоид</i></b>
<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.12.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.7)</td>
</tr></tbody></table>	 		 						
в отличие от предыдущих поверхностей имеет только две плоскости симметрии: <i>XOZ</i> и <i>YOZ</i> и одну ось симметрии: <i>OZ</i>. Его можно получить вращением параболы вокруг его оси симметрии и последующим сжатием. Эллиптический параболоид (8.7) имеет форму “чашки”, стоящей на плоскости <i>XOY</i> (точнее она касается плоскости <i>XOY</i> в начале координат); плоскости, параллельные <i>XOY</i> и лежащие ниже нее, не пересекают эллиптический параболоид, а лежащие выше – дают в сечениях эллипсы. Плоскости <i>XOZ</i> и <i>YОZ</i> и им параллельные дают в сечениях параболы. При сечении эллиптического параболоида (8.7) остальными плоскостями ничего другого мы получать не будем: либо плоскость пересекает параболоид (8.7) по эллипсу, либо по параболе, либо плоскость имеет одну общую точку с параболоидом (точку касания), либо, наконец, плоскость вообще не пересекает параболоид (8.7).
<br>Эллиптический параболоид вращения со времен Архимеда широко используется в технике, так как он обладает оптическим свойством параболы.

<br><b><i>6. Гиперболический параболоид</i></b>
<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.13.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.8)</td>
</tr></tbody></table>	 		 						
как и эллиптический параболоид, имеет две плоскости симметрии (<i>XOZ</i> и <i>YOZ</i>) и одну ось симметрии (<i>OZ</i>). 
В отличие от рассмотренных выше поверхностей, он не есть результат вращения кривой. Он имеет форму седла. Гиперболический параболоид (8.8) пересекает плоскость <i>ХОZ</i> по параболе <i>x</i><sup><font size="2">2</font></sup> = 2<i>pz</i>, ветви которой обращены вверх, а плоскость <i>YOZ</i> – по параболе – <i>y</i><sup><font size="2">2</font></sup> = 2<i>pz</i>, ветви которой обращены вниз. Вся поверхность может быть получена параллельным перемещением – скольжением второй параболы по первой. Любая плоскость пересекает гиперболический параболоид, в сечении могут получаться параболы, гиперболы (но не эллипсы) и пары пересекающихся прямых. Например, при сечении гиперболического параболоида (8.8) плоскостью <i>XOY</i> получаются прямые: <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.14.JPG" align="MIDDLE"> и <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.15.JPG" align="MIDDLE">. 
<br>Последнее означает, что гиперболический параболоид состоит из прямых (как и однополостный гиперболоид), поэтому эта поверхность также находит применение в строительстве.

<br><b><i>7. Эллиптический, гиперболический и параболический цилиндры</i></b>
<br>Поверхность, образованная параллельными прямыми (образующими), проходящими через все точки некоторой линии (направляющей), 
называется <b><i>цилиндрической</i></b> или <b><i>цилиндром</i></b>.
<br>Например, цилиндром является поверхность, уравнение которой явно не содержит <i>z</i>, т.е. имеет вид <i>F</i>(<i>x</i>, <i>y</i>) = 0. 
В самом деле, эта поверхность состоит из прямых (образующих), параллельных оси <i>OZ</i> и проходящих через все точки кривой (направляющей), лежащей в плоскости <i>XOY</i> и уравнение которой имеет тот же вид, что и уравнение поверхности –<i>F</i>(<i>x</i>, <i>y</i>) = 0.
<br>В частности уравнения
<br> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.8.JPG" align="MIDDLE">, ­ ­ ­ <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.16.JPG" align="MIDDLE">, ­ ­ ­ <i>y</i><sup><font size="2">2</font></sup> = 2<i>pz</i> 
<br>определяют цилиндры, с соответствующими направляющими: эллипсом, гиперболой и параболой на плоскости <i>XOY</i>. Следует обратить внимание на то, что в нашем случае, хотя уравнения цилиндрических поверхностей и их направляющих имеют один и тот же вид, но смысл этих уравнений различный: в первом случае этому уравнению удовлетворяют координаты <i>точек пространства</i> 
(<i>Х</i>, <i>Y</i>, <i>Z</i>). во втором – координаты <i>точек плоскости</i> (<i>Х</i>, <i>Y</i>).Все сказанное относительно уравнений, которые явно не содержат <i>z</i>, естественно, справедливо и для уравнений, которые явно не содержат <i>Y</i> или <i>Х</i>, так уравнение <i>F</i>(<i>x</i>, <i>z</i>) = 0 определяет цилиндр с образующими, параллельными оси <i>OY</i>, а <i>F</i>(<i>y</i>, <i>z</i>) = 0 – цилиндр с образующими, параллельными оси <i>ОX</i>.

<h3>Классификация основных алгебраических поверхностей второго порядка</h3>
<table frame="border">
<tbody><tr>
<td align="CENTER"> Номер вида </td>
<td align="CENTER"> Уравнение поверхности </td>
<td align="CENTER"> Название поверхности </td>
<td align="CENTER"> Рисунок поверхности </td>
</tr>

<tr>
<td align="CENTER"> 1</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.7.JPG"> </td>
<td align="CENTER"> Эллипс </td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.17.JPG"></td>
</tr>

<tr>
<td align="CENTER"> 2</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.9.JPG"> </td>
<td align="CENTER"> Однополостный гиперболоид </td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.18.JPG"></td>
</tr>

<tr>
<td align="CENTER"> 3</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.10.JPG"> </td>
<td align="CENTER"> Двуполостный гиперболоид </td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.19.JPG"></td>
</tr>

<tr>
<td align="CENTER"> 4</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.11.JPG"> </td>
<td align="CENTER"> Конус второго порядка </td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.20.JPG"></td>
</tr>

<tr>
<td align="CENTER"> 5</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.12.JPG"> </td>
<td align="CENTER"> Эллиптический параболоид</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.21.JPG"></td>
</tr>

<tr>
<td align="CENTER"> 6</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.13.JPG"></td>
<td align="CENTER"> Гиперболический параболоид</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.22.JPG"></td>
</tr>

<tr>
<td align="CENTER"> 7</td>
<td align="CENTER"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.8.JPG"> </td>
<td align="CENTER"> Эллиптический цилиндр </td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.23.JPG"></td>
</tr>

<tr>
<td align="CENTER">8</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.16.JPG"></td>
<td align="CENTER"> Гиперболический цилиндр</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.24.JPG"></td>

</tr><tr>
<td align="CENTER"> 9</td>
<td align="CENTER"> <i>y</i><sup><font size="2">2</font></sup> = <i>px</i>; ­  (<i>p</i> &gt; 0)</td>
<td align="CENTER"> Параболический цилиндр</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.25.JPG"></td>
</tr>
</tbody></table> 

<h3>8.3 СОДЕРЖАНИЕ ТИПОВОГО РАСЧЕТА</h3>
Семь алгебраических поверхностей второго порядка заданы уравнениями вида 
<table><tbody><tr>
<td align="CENTER" width="100%"> <i>Ax</i><sup><font size="2">2</font></sup> + <i>By</i><sup><font size="2">2</font></sup> 
+ <i>Cz</i><sup><font size="2">2</font></sup> + <i>Dx</i> + <i>Ey</i> + <i>Fz</i> + <i>G</i> = 0 </td>
<td align="RIGHT" width="20%">(8.9)</td>
</tr></tbody></table> 				
Определить тип каждой поверхности и сделать рисунок.
<h3>8.4 ПРИМЕР ВЫПОЛНЕНИЯ ТИПОВОГО РАСЧЕТА</h3>
 В условии заданы коэффициенты уравнения (8.9) в виде таблицы:

<br><br>
<table frame="border">
<tbody><tr>
<td align="CENTER"> ­ ­ N ­ ­ </td>
<td align="CENTER"> ­ ­ A ­ ­ </td>
<td align="CENTER"> ­ ­ B ­ ­ </td>
<td align="CENTER"> ­ ­ C ­ ­ </td>
<td align="CENTER"> ­ ­ D ­ ­ </td>
<td align="CENTER"> ­ ­ E ­ ­ </td>
<td align="CENTER"> ­ ­ F ­ ­ </td>
<td align="CENTER"> ­ ­ G ­ ­ </td>
</tr>
<tr>
<td align="CENTER">  1 </td>
<td align="CENTER">  1 </td>
<td align="CENTER"> –4 </td>
<td align="CENTER"> –1 </td>
<td align="CENTER">  2 </td>
<td align="CENTER"> –8 </td>
<td align="CENTER">  2</td>
<td align="CENTER">  0 </td>
</tr>
</tbody></table>

<br>Приведем решение этой задачи. По условию уравнение имеет вид
<br><i>x</i> <sup><font size="2">2</font></sup> – 4<i>y</i> <sup><font size="2">2</font></sup> – <i>z</i> <sup><font size="2">2</font></sup> + 2<i>x</i> – 8<i>y</i> + 2<i>z</i> = 0.
<br>Выделим полные квадраты и приведем уравнение к виду:
<br>(<i>x</i> <sup><font size="2">2</font></sup> + 2<i>x</i> + 1) – 1 – 4(<i>y</i> + 1)<sup><font size="2">2</font></sup> 
+ 4 – (<i>z</i> – 1)<sup><font size="2">2</font></sup> + 1 = 0 
<br>(<i>x</i> + 1)<sup><font size="2">2</font></sup> – 4(<i>y</i> + 1)<sup><font size="2">2</font></sup> – (<i>z</i> – 1)<sup><font size="2">2</font></sup> = – 4 
<br><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.26.JPG" align="MIDDLE">

<br>Положим <i>x'</i> = <i>x</i> + 1, ­ ­ <i>y'</i> = <i>y</i> + 1 ­ и  ­ <i>z'</i> = <i>z</i> – 1. 
Это означает переход к новой ДПСК, которая получается из данной параллельным переносом и начало которой в т. 
<i>O'</i> (–1, –1, 1). 
<br>Теперь, наше уравнение примет вид:

<table><tbody><tr>
<td align="CENTER" width="100%"><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.27.JPG" align="MIDDLE"> ­ ­ или ­ ­ <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.28.JPG" align="MIDDLE"></td>
<td align="RIGHT" width="20%">(8.10)</td>
</tr></tbody></table>	 	 
и мы можем определить тип поверхности – однополостный гиперболоид, “нанизанный” на ось абсцисс новой ДПСК, т.е. на прямую, параллельную оси <i>OX</i> и проходящую через т. <i>O'</i> (–1, –1, 1) (заметим, что уравнение (8.10) не является в 
строгом смысле каноническим уравнением однополостного гиперболоида; чтобы его получить, нужно “поменять” оси <i>O' X'</i> и <i>O' Z'</i>, т.е. повернуть ДПСК <i>O' X' Y' Z'</i> вокруг оси <i>O' Y'</i> на 90° по часовой стрелке).

<h3>Сводка полученных результатов</h3>
<table frame="border">
<tbody><tr>
<td align="CENTER"> Данное уравнение поверхности</td>
<td align="CENTER"> <i>x</i> <sup><font size="2">2</font></sup> – 4<i>y</i> <sup><font size="2">2</font></sup> – <i>z</i> <sup><font size="2">2</font></sup> + 2<i>x</i> – 8<i>y</i> +2<i>z</i> = 0 </td>
</tr>

<tr>
<td align="CENTER"> Уравнение поверхности относительно ДПСК
<br><i>O'X'Y'</i> (после параллельного переноса)</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.29.JPG"> </td>
</tr>

<tr>
<td align="CENTER">Название поверхности</td>
<td align="CENTER"> Однополостный гиперболоид </td>
</tr>

<tr>
<td align="CENTER"> Связь между координатами
<br>Точки (<i>X, Y, Z</i>) и  (<i>X', Y', Z'</i> )</td>
<td align="CENTER"> <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.30.JPG"> ­ ­ ­ ­ <img src="./Пример выполнения типового расчета 1.8_files/ris1.8.31.JPG"></td>
</tr>

<tr>
<td align="CENTER"> Координаты центра  <i>O'</i></td>
<td align="CENTER"> (–1, –1, 1)</td>
</tr>
</tbody></table>
<p>
</p><center><img src="./Пример выполнения типового расчета 1.8_files/ris1.8.32.JPG" align="MIDDLE"> 
<br>Однополостный гиперболоид
<br>Рис. 8.1 </center> 

<h3>8.5 Оформление отчета</h3>
Все результаты каждой задачи должны быть сведаны в таблицу, как это сделано в примере. Таблица должна содержать данные уравнение поверхности, каноническое уравнение и название поверхности: формулы, связывающие координаты точки относительно рассматриваемых ДПСК, координаты начала новой ДПСК в данной ДПСК.
<br>Должен быть сделан аккуратный рисунок поверхности в данной ДПСК.
<br>Работа должна содержать не только ответы на вопросы, поставленные в задании, но и все вычисления, на основании которых 
сделаны выводы.




</body></html>